[{"title":"hexo添加网易云音乐","date":"2017-02-15T06:45:11.000Z","path":"2017/02/15/hexo添加网易云音乐/","text":"刚开始做blog的时候就想加入音乐功能，当时自己折腾了半天也没弄出来，今天看到一篇教程，然后结合自己所学，终于搞出来了。 我用的是Yilia主题，就用这个来讲。先要拿到网易云音乐的外链播放器，进入网易云音乐官网，右上角我的主页 下面拉找到我的歌单，可以专门为blog建个歌单， 生产外链播放器，用iframe插件 我测试是宽280px,高90px大小比较合适 最后打开（themes/yilia/layout/_partial/left-col.ejs） 教程里面写的是放在第二行，就是把播放器放在左边栏上面，我不太喜欢这样，而且容易把下面的分类信息压到屏幕外，就想放在下面。问题来了，本以为放在代码最下放就好了，可是调试后发现位置偏差了，原因是被left-col里的样式控制了，音乐框会跑到中间位置，后我找到css文件（/themes/yilia/source-src/css/left.scss），把默认的头像背景色块大小减小到150px，颜色也可以改 头像上移margin: 80px auto 0; 中间menu位置上移，用了margin-top:-20px; 本以为完成了，hexo d -g，hexo s，后发现头像等位置没有上移，后阅读yilia作者Yilia源码目录结构及构建须知,发现需要编译压缩，修改的参数才能生效 编译是还发生了些小的问题，所幸安装一些依赖（node-sass，ejs）后都成功完成了，最后结果如下 自己还是比较满意的，这个让我重新了解了编译过程，依赖安装等等，就写了篇日记纪念下 因为还不知道pc端转移动端的代码在哪，所以移动端以后再做，最近还想把自己做的一些demo在blog上展示出来，但是写在hexo里面会被默认样式所影响，所以需要把hexo安装在子文件夹里，用自己写的页面当做网站主页面，hexo当子页面，应该可以展示，继续加油吧","tags":[{"name":"hexo","slug":"hexo","permalink":"https://relax89757.github.io/tags/hexo/"}]},{"title":"变量、值与类型(1)","date":"2017-02-14T10:54:03.000Z","path":"2017/02/14/变量、值与类型/","text":"JS类型js有七种数据类型，Undefined、Null、Boolean、String、Number、Symbols、Object.function也是一种可引用的Object。判断数据类型一般可用typeof，12345678typeof NaN; //&quot;number&quot;typeof Infinity; //&quot;number&quot;typeof ture; //&quot;boolean&quot;typeof Null; //&quot;object&quot;typeof Undefined; //&quot;undefined&quot;typeof symbol(); //&quot;symbol&quot;typeof function()&#123;&#125;; //&quot;function&quot;NaN == NaN //false 变量声明js变量声明有3种方式： var-常用的声明变量，会变量提升 let-声明有块级作用域的变量，如for循环里的i const-声明一个只读的常量 var注意事项 无块级作用域 变量提升123456789101112console.log(a); //undefinedvar a = 10;function foo()&#123; console.log([a, i]); //undefined,undefined foo函数也提升了 var a = 20; for(var i=0; i&lt;a; i++)&#123; console.log(a); //20 console.log(i); //i重复20 i没有块级作用域，所以显示的是循环完成后的值，以前只能用 闭包或立即执行函数，现可用let可打印1-20的值 &#125;； &#125; let注意事项 块级作用域 同一作用域只能声明一次，重复声明会报错 暂存死区-变量不会提前，在声明前面引用会报错 循环中的let作用域 浏览器兼容问题 const注意事项 const声明变量的值不能再次改变 其他和let一样 不声明使用12345(function foo()&#123; var x = y = 10; //等于var x=y; y=10;y没有声明是全局的&#125;)();console.log([typeof x, typeof y]); //[&quot;undefined&quot;, &quot;number&quot;] 相等==与=== ==为非严格相等，类型可以转换 ===为严格相等，类型不能转换 NaN与任何值（包括自身）都不相等 123null == undefined; //turenull === undefined; //falseconsole.log([1 == &quot;1&quot;, 0 == &quot;&quot;, 0 == [], 0 == false, 1 == true]); //都是ture Boolean类型 true和false 0、、””、undefined、null隐形转化为false，其他为true。 采用严格比较可以用!!将非boolean值转化为boolean值。 布尔操作符&amp;&amp;和||不会改变数据类型。 &amp;&amp;和||的短路特性,&amp;&amp;中第一个表达式为假就不会去处理第二个表达式，而||正好相反。 &amp;&amp;两个表达式为true，取第二个表达式值，||取第一个表达式值 比较操作返回boolean 1234567var result = 1 &amp;&amp; 2;console.log([result, !!result]); //[2, true]function showTip(tip)&#123; tip = tip || &quot;this is a tip&quot; //利用||短路特性来设置参数默认值 //if(!tip)&#123;tip = &quot;this is a tip&quot;&#125;;&#125; Number类型 数值范围 整数范围为-2^53~2^53 小数范围为Number.EPSILON infinity（无穷大）、Number.MAX_VALUE、Number.MIN_VALUE 浮点数精度问题（0.1+0.2 != 0.3） toFixed() 方法指定小数位个数 toExponential() 方法 用科学计数法表示数，参数指定小数位个数 toPrecision()方法自动判断调用toFixed()或toExponential()方法,参 数指定所有数的位数 123456var num = 99; console.log(num.toFixed(2)); //99.00 console.log(num.toExponential(1)); //9.0e+1 console.log(num.toPrecision(1)); //9.0e+1 console.log(num.toPrecision(2)); //99 console.log(num.toPrecision(3)); //99.0 String类型类型引号规范和转义123var text = &apos;this is a text&apos;; //规范建议用单引号，因为拼接字符串时属性里经常会用到双引号var html = &apos;&lt;p class=&quot;sth&quot;&gt;this is a &lt;em&gt;paragraph&lt;/em&gt;&lt;/p&gt;&apos;;var text2 = &apos;我的东西\\n是全天下\\n最好的&apos;;// \\n是回车的转义，\\t缩进 处理字符123456var str = &apos;my string&apos;;console.log(str.charAt(5));//&quot;r&quot;,数字从0开始，计算空格var charArray = Array.from(str);//同str.split(&apos;&apos;);把字符串分割为单个字的数组.console.log(charArray);//&#123;&quot;m&quot;, &quot;y&quot;, &quot;&quot;, &quot;s&quot;, &quot;t&quot;, &quot;r&quot;, &quot;i&quot;, &quot;n&quot;, &quot;g&quot;,&#125;;console.log(str.charAt(5),str.charCodeAt(6));//charCodeAt返回字符编码console.log(String.fromCharCode(charArray.map(...c=&gt;c.charCodeAt(0)))) 字符串类型转换12console.log([1+2, &apos;1&apos;+2, &apos;1&apos;-2]);//[3,&apos;12&apos;,-1] &apos;1&apos;+2被转换为字符串拼接了，如要得到3可写&apos;1&apos;-0+2,&apos;1&apos;-2被转换为数字了console.log(parseInt(&apos;100abc&apos;))//100字符串转数字，忽略abc","tags":[{"name":"前端","slug":"前端","permalink":"https://relax89757.github.io/tags/前端/"}]},{"title":"ES6新类型Symbol","date":"2017-02-13T07:48:41.000Z","path":"2017/02/13/ES6新类型Symbol/","text":"symbol为es6新加入的数据类型，symbol的作用是 1.Symbol()–&gt;解决属性名的冲突,因为传入对象属性时,同样的Symbol不相等;解释:什么是冲突呢？当多人合作编码的时候，经常会出现你往对象上加了一个某某属性（比如 $ ），他人正好也想到了这个名称，当你们同时用了这个名称作为属性，代码之间就会发生冲突，互相覆盖。而用 symbol，即使都用了相同的描述，也不是同一个 symbol。2.Symbol.for()–&gt;共享Symbol,因为返回值得不一样,keyFor()用来查看它的描述 symbol特点 1.Symbol(‘key’) !== Symbol(‘key’) //true,返回不同2.Symbol(“know”).name = 1; // TypeError,只读3.for…in 、 Object.keys(obj) 、Object.getOwnPropertyNames(obj)会忽略Symbol,即自身不可枚举4.不能用obj.prop的形式访问 symbol用法1234567// create a unique symbol var isMoving = Symbol(&quot;isMoving&quot;); ... if (element[isMoving]) &#123; smoothAnimations(element); &#125; element[isMoving] = true; 关于这段代码的几个说明： Symbol(“isMoving”)中的“isMoving”被称作描述。它对调试很有用。当你使用console.log()就可以打印出对应的symbol值，如果你想把它转换为字符串（比如说在打印错误信息的时候）可以使用.toString()。 element[isMoving]被称作symbol-keyed属性（使用symbol作为键的属性）。从字面意思就可以说明它就是使用symbol作为属性名而不是使用字符串。除去这一点，它和其它属性并没什么区别。 和数组元素一样，symbol-keyed属性不能通过圆点符号来获取值（obj.name 这样是不行的）。它的值必须通过方括号来获取。 通过symbol的值获取symbol-keyed属性值就很容易了。上面的例子展示了如何获取和设置element[isMoving]，我们可以判断元素的isMoving状态了，如果有必要的话甚至可以删除isMoving状态。 另一方面，以上的前提是isMoving在当前作用域中。这体现了symbols的弱封装机制：一个模块可以创建几个symbols在对象中任意使用而不用担心与其它模块的属性冲突。 因为symbol键值是被设计来避免冲突的，所以JavaScript最基本的对象检测特性是会忽略symbol键值的。以for-in循环为例，循环只会遍历对象的字符串类型的键。Symbol键直接被忽略过了。Object.key(obj)和Object.getOwnPropertyNames(obj)也是这样运作的。但是sysmbols并不完全是私有的：可以使用新API——Object.getOwnPropertySymbols(obj)将所对象的所有symbol键；另一个新API—— Reflect.ownKeys(obj)，将会同时返回string和symbol类型的键。","tags":[{"name":"前端","slug":"前端","permalink":"https://relax89757.github.io/tags/前端/"}]},{"title":"绝对定位居中布局","date":"2016-10-27T12:46:10.000Z","path":"2016/10/27/绝对定位居中布局/","text":"前言绝对定位并且居中显示，在开发中经常用到。总结了一下这种布局的三种方法，备忘。 方法一123456position: absolute:top: 0;bottom: 0;left: 0;right: 0;margin:auto; 方法二1234567position: absolute;left: 50%; top: 50%;margin-top: -20%; //子div宽高的一半margin-left: -40%;width: 80%;height: 40%; 方法三12345position: absolute;left: 50%; top: 50%;transform: translate(-50%, -50%); /* 50%为自身尺寸的一半 */margin: auto; 后记以上三种绝对定位居中布局方法，同样适用于固定定位，即position:fixed;，只不过是相对的容器变成了浏览器。","tags":[{"name":"css","slug":"css","permalink":"https://relax89757.github.io/tags/css/"}]},{"title":"北高峰图记","date":"2016-10-27T08:25:55.000Z","path":"2016/10/27/北高峰图记/","text":"去年和小伙伴登高北高峰，特此写下此图记。","tags":[{"name":"旧事","slug":"旧事","permalink":"https://relax89757.github.io/tags/旧事/"}]},{"title":"前端demo","date":"2016-10-27T08:12:20.000Z","path":"2016/10/27/前端demo/","text":"","tags":[]}]